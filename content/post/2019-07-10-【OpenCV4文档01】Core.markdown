---
layout:     post
title:      【OpenCV4文档01】Core
subtitle:   学习OpenCV核心库Core的构建模块等
date:       2019-07-10
author:     Bingo
header-img: img/post-bg-open4v.png
catalog: true
tags:
    - 机器学习
    - 图像处理
    - Java
    - OpenCV
    - Core
---

# 矩阵：基本图像容器
- 兼容性：> OpenCV 2.0
您将学习如何将图像存储在内存中以及如何将其内容打印到控制台。

我们有多种方法可以从现实世界中获取数字图像：数码相机，扫描仪，计算机断层扫描和磁共振成像等等。
在每种情况下，我们（人类）看到的都是图像。
然而，当将其转换为我们的数字设备时，我们记录的是图像的每个点的数值。
![汽车mat](https://docs.opencv.org/4.1.0/MatBasicImageForComputer.jpg)
例如，在上图中，您可以看到汽车的镜子只不过是一个包含像素点所有强度值的矩阵。
我们如何获取和存储像素值可能根据我们的需要而变化，但最终计算机世界中的所有图像可以简化为数字矩阵和描述矩阵本身的其他信息。
OpenCV是一个计算机视觉库，其主要重点是处理和操作这些信息。
因此，您需要熟悉的第一件事是OpenCV如何存储和处理图像。

### 矩阵：Mat
OpenCV自2001年开始出现。那时候，这个库是围绕一个C接口构建的，并将图像存储在内存中，它们使用了一个名为IplImage的C结构。
这是您在大多数旧教程和教学材料中看到的内容。
这样做的问题是它带来了C语言的所有缺点。
最大的问题是手动内存管理。
它建立在用户负责处理内存分配和释放的假设之上。
虽然这对于较小的程序来说不是问题，但是一旦你的代码库增长，处理所有这些问题将更加困难，而不是专注于解决你的开发目标。

幸运的是，C ++出现并通过自动内存管理（或多或少）引入了类更容易让用户使用的概念。
好消息是C ++与C完全兼容，因此进行更改不会产生兼容性问题。
因此，OpenCV 2.0引入了一种新的C ++接口，它提供了一种新的处理方式，这意味着您不需要操作内存管理，使您的代码更简洁（更少编写，实现更多）。
C ++界面的主要缺点是目前许多嵌入式开发系统只支持C.因此，除非你的目标是嵌入式平台，否则使用旧方法是没有意义的（除非你是一个受虐狂的程序员，你要问的是
麻烦）。

关于Mat，您需要了解的第一件事是，您不再需要手动分配其内存并在不需要时立即释放它。
虽然这样做仍有可能，但大多数OpenCV函数都会自动分配其输出数据。
如果您传递已经存在的Mat对象（已经为矩阵分配了所需的空间），这将是一个很好的奖励，这将被重用。
换句话说，我们始终只使用执行任务所需的内存。

Mat基本上是一个包含两个数据部分的类：矩阵头（包含诸如矩阵大小，用于存储的方法，存储矩阵的地址等信息）和指向包含矩阵的矩阵的指针。
像素值（取决于选择存储的方法取任何维度）。
矩阵标题大小是恒定的，但是矩阵本身的大小可能因图像而异，并且通常大于数量级。

OpenCV是一个图像处理库。
它包含大量图像处理功能。
为了解决计算挑战，大多数时候您最终会使用库的多个功能。
因此，将图像传递给函数是一种常见的做法。
我们不应该忘记我们正在讨论图像处理算法，这些算法往往计算量很大。
我们要做的最后一件事是通过制作不必要的潜在大图像副本来进一步降低程序的速度。

为解决此问题，OpenCV使用引用计数系统。
这个想法是每个Mat对象都有自己的头，但是矩阵可以通过让矩阵指针指向同一个地址来共享它们的两个实例。
此外，复制操作符只会将标题和指针复制到大矩阵，而不是数据本身。

``` c++
Mat A, C;                          // creates just the header parts
A = imread(argv[1], IMREAD_COLOR); // here we'll know the method used (allocate matrix)
Mat B(A);                                // Use the copy constructor
C = A;                                    // Assignment operator
```
最后，所有上述对象都指向相同的单个数据矩阵。
但是，它们的标题不同，并且使用它们中的任何一个进行修改也会影响所有其他标题。
实际上，不同的对象只是为相同的底层数据提供不同的访问方法。
然而，他们的标题部分是不同的。
真正有趣的部分是您可以创建仅涉及完整数据的子部分的标题。
例如，要在图像中创建感兴趣区域（ROI），只需使用新边界创建新标题：
```c++
Mat D (A, Rect(10, 10, 100, 100) ); // using a rectangle
Mat E = A(Range::all(), Range(1,3)); // using row and column boundaries
```
现在您可能会问矩阵本身是否属于多个Mat对象，这些对象在不再需要时负责清理它。
简短的回答是：使用它的最后一个对象。
这是通过使用引用计数机制来处理的。
每当有人复制Mat对象的标题时，矩阵的计数器就会增加。
每当清洁标题时，该计数器就会减少。
当计数器达到零时，矩阵也被释放。
有时您也希望复制矩阵本身，因此OpenCV提供了cv :: Mat :: clone（）和cv :: Mat :: copyTo（）函数。
```c++
Mat F = A.clone();
Mat G;
A.copyTo(G);
```
现在修改F或G不会影响Mat头指向的矩阵。
你需要记住的是：
- OpenCV函数的输出图像分配是自动的（除非另有说明）。
- 您不需要考虑使用OpenCVs C ++接口进行内存管理。
- 赋值运算符和复制构造函数仅复制标题。
- 可以使用cv :: Mat :: clone（）和cv :: Mat :: copyTo（）函数复制图像的基础矩阵。

### 存储方法
这是关于如何存储像素值。您可以选择颜色空间和使用的数据类型。颜色空间指的是我们如何组合颜色组件以编码给定颜色。最简单的是灰度，我们处理的颜色是黑色和白色。这些组合使我们可以创建许多灰色阴影。

对于丰富多彩的方式，我们有更多的方法可供选择。它们中的每一个都将其分解为三个或四个基本组件，我们可以使用这些组合来创建其他组件。最受欢迎的是RGB，主要是因为这也是我们的眼睛如何建立颜色。它的基色是红色，绿色和蓝色。要编码颜色的透明度，有时会加第四个元素：添加alpha（A）。

还有许多其他颜色系统各有其优点：
- RGB是最常见的，因为我们的眼睛使用类似的东西，但请记住，OpenCV标准显示系统使用BGR颜色空间（红色和蓝色通道的开关）组成颜色。
- HSV和HLS将颜色分解为色调，饱和度和值/亮度分量，这是我们描述颜色的更自然的方式。例如，您可能会忽略最后一个组件，使您的算法对输入图像的光照条件不太敏感。
- YCrCb由流行的JPEG图像格式使用。
- CIE L * a * b *是一个感知上均匀的色彩空间，如果您需要测量给定颜色与另一种颜色的距离，它会派上用场。

每个构建组件都有自己的有效域。这导致使用的数据类型。我们如何存储组件定义了我们对其域的控制。可能的最小数据类型是char，这意味着一个字节或8位。这可能是无符号的（因此可以存储0到255之间的值）或有符号（值从-127到+127）。虽然在三个组件的情况下，这已经提供了1600万种可能的颜色来表示（如在RGB的情况下），我们可以通过使用浮点（4字节= 32位）或双（8字节= 64位）数据来获得更精细的控制每个组件的类型。不过，请记住，增加组件的大小也会增加内存中整个图片的大小。

### 明确的创建一个Mat对象
在“加载，修改和保存图像”教程中，您已经学习了如何使用cv :: imwrite（）函数将矩阵写入图像文件。但是，出于调试目的，查看实际值会更方便。您可以使用Mat的<<运算符来执行此操作。请注意，这仅适用于二维矩阵。

尽管Mat作为图像容器工作得很好，但它也是一般的矩阵类。因此，可以创建和操纵多维矩阵。您可以通过多种方式创建Mat对象：
- cv::Mat::Mat 构造函数
```c++
Mat M(2,2, CV_8UC3, Scalar(0,0,255));
cout << "M = " << endl << " " << M << endl << endl;
```


